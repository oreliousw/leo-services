#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Leo System Command â€“ leo
================================================
Version: 1.9.2 (refined daily ops)
Purpose:
- Lean operator interface for daily MES management
- Enforces safe SOURCE â†’ DEPLOY workflow
Changes in 1.9.2:
- Simplified: only 'leo deploy code' for pushing updates
- Removed demo/live deploy options (code is identical anyway)
- Risk lives in mes-run / service env, not deploy
"""
import sys
import subprocess
from datetime import datetime
from shutil import which
from pathlib import Path

# ============================================================
# Paths
# ============================================================
LEO_SRC = Path.home() / "leo-services" / "leo" / "bin"
MES_SCALP_SRC = Path.home() / "leo-services" / "mes" / "mes_scalp.py"
MES_SWING_SRC = Path.home() / "leo-services" / "mes" / "mes_swing.py"
MES_SCALP_DEST = Path("/opt/mes/mes_scalp.py")
MES_SWING_DEST = Path("/opt/mes/mes_swing.py")
EDITABLE_FILES = {
    "mes-run": LEO_SRC / "mes-run",
    "leo": LEO_SRC / "leo",
}

# ============================================================
# Helpers
# ============================================================
def run(cmd: str):
    subprocess.run(cmd, shell=True, check=True)

def red(text: str):
    print(f"\033[91m{text}\033[0m")

def green(text: str):
    print(f"\033[92m{text}\033[0m")

def yellow(text: str):
    print(f"\033[93m{text}\033[0m")

def header():
    print("\n=== LEO SYSTEM ===")
    print(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

def has_cmd(cmd: str) -> bool:
    return which(cmd) is not None

def open_editor(path: Path):
    if not path.exists():
        red(f"File not found: {path}")
        return
    if has_cmd("code"):
        run(f"code --wait {path}")
    elif has_cmd("vim"):
        run(f"vim {path}")
    elif has_cmd("nano"):
        run(f"nano {path}")
    else:
        red("No editor found (code/vim/nano)")

def confirm(prompt: str) -> bool:
    while True:
        r = input(f"{prompt} (y/n): ").lower().strip()
        if r in ("y", "yes"):
            return True
        if r in ("n", "no"):
            return False
        print("Please answer y or n.")

# ============================================================
# Core Deploy Code
# ============================================================
def deploy_code():
    header()
    yellow("Deploying latest MES code (scalp + swing) to active use...")
    try:
        run(f"sudo cp -f {MES_SCALP_SRC} {MES_SCALP_DEST}")
        run(f"sudo cp -f {MES_SWING_SRC} {MES_SWING_DEST}")
        run(f"sudo chmod 644 {MES_SCALP_DEST} {MES_SWING_DEST}")
    except subprocess.CalledProcessError:
        red("Copy failed")
        sys.exit(1)
    run("sudo systemctl restart mes_scalp_demo.service mes_scalp_live.service mes_swing_demo.service mes_swing_live.service 2>/dev/null || true")
    green("âœ” Latest code deployed â€“ ready for demo or live services")

# ============================================================
# Usage
# ============================================================
def usage():
    header()
    print("Daily commands:\n")
    print(" leo status       System health overview")
    print(" leo edit [leo|mes-run] Edit operator tools + optional install")
    print(" leo deploy code  Copy latest scalp + swing to active use")
    print(" leo mes          MES operator (mes-run wrapper)")
    print(" leo update       System package updates")
    print(" leo reboot       Reboot system (confirm)\n")
    sys.exit(0)

# ============================================================
# Commands
# ============================================================
def status():
    header()
    run("uptime")
    print("")
    run("df -h / | tail -n 1")
    print("")
    try:
        run("systemctl --failed")
    except subprocess.CalledProcessError:
        pass

def edit():
    header()
    if len(sys.argv) == 2:
        print("Editable operator files:\n")
        for k in EDITABLE_FILES:
            print(f" leo edit {k}")
        print("")
        return
    target = sys.argv[2].lower()
    if target not in EDITABLE_FILES:
        red(f"Unknown target: {target}")
        edit()
        return
    path = EDITABLE_FILES[target]
    print(f"Opening {path} ...")
    open_editor(path)
    if confirm(f"Install updated {target} now?"):
        installer = LEO_SRC / "leo-install"
        if not installer.exists():
            red("leo-install script missing")
            return
        run(str(installer))
        green(f"\nâœ” {target} installed")

def deploy():
    deploy_code()  # only one deploy path now

def mes():
    if len(sys.argv) > 2:
        run(f"mes-run {' '.join(sys.argv[2:])}")
    else:
        run("mes-run status")

def update():
    header()
    run("sudo apt update")
    run("sudo apt upgrade -y")
    run("sudo apt autoremove -y")
    green("\nã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆå®Œäº† ðŸ˜º")

def reboot():
    header()
    if confirm("Reboot Leo system now?"):
        run("sudo reboot")

# ============================================================
# Entrypoint
# ============================================================
if __name__ == "__main__":
    if len(sys.argv) == 1 or sys.argv[1] in ("help", "-h", "--help"):
        usage()
    cmd = sys.argv[1].lower()
    if cmd == "status":
        status()
    elif cmd == "edit":
        edit()
    elif cmd == "deploy":
        deploy()
    elif cmd == "mes":
        mes()
    elif cmd == "update":
        update()
    elif cmd == "reboot":
        reboot()
    else:
        red(f"Unknown command: {cmd}")
        usage()